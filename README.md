
Process Creation and Management (30%)
Description: In this activity, you will implement a program that utilizes the fork() function to create and manage processes. The program should allow you to specify, through a command-line parameter, how many child processes should be created. Each child process will be responsible for calculating a part of a summation of a list of integers. The range of numbers to be calculated by each child process should also be passed as a parameter. You must divide the list of numbers evenly among the child processes, so that each one calculates the sum of a specific subset. After the calculation, the child processes must communicate with the parent process to send the partial results. The parent process will receive the partial results from the child processes and calculate the total sum by combining the received values. Ensure to properly terminate the child processes, ensuring that they are all terminated at the end of the program execution or when a specified exit condition is reached. Objective: The objective of this activity is to provide practical experience in creating and managing processes.

Process Scheduling (35%)
Description: Develop a program that simulates the following process scheduling algorithms: First-Come, First-Served (FCFS); Round Robin (RR); and Shortest Job First (SJF). Implement each of these algorithms in a way that allows for easy comparison. Your program should accept a list of processes, each with a specific arrival time and duration.
First-Come, First-Served (FCFS): In this algorithm, processes are served in the order they arrive, meaning the first to arrive is the first to be processed.
Round Robin (RR): In this algorithm, each process is assigned a fixed quantum of time. Processes are served in a circular order, with each process being interrupted after its quantum expires to make way for the next in the queue, returning to the end of the queue if necessary.
Shortest Job First (SJF): In this algorithm, processes with the shortest execution times are served first, prioritizing those that can be completed more quickly. Consider the possibility of enabling preemptive mode by passing it as a parameter.
While simulating these algorithms, analyze the system performance regarding metrics such as waiting time (how long processes wait before being processed), response time (time between process submission and first response), processing time (total time required to complete the process), and turnaround time (time elapsed from when the process enters until it finishes execution). Objective: The objective of this activity is to help you understand how different scheduling algorithms work and how they influence the performance of the operating system.

Deadlock Detection and Prevention (35%)
Description: In this activity, you will create a program to simulate deadlock situations in an operating system. Start by implementing deadlock detection techniques to identify when a deadlock occurs. In a simulated system, you can use data structures such as matrices or lists to represent processes, available resources, and the relationships between them. Implement a deadlock detection algorithm, such as the circular wait algorithm or the wait-for graph algorithm, to monitor the use of resources by processes. Check for the existence of a wait cycle among processes waiting for resources. Next, implement deadlock prevention strategies, such as the banker's algorithm, to avoid deadlocks. The banker's algorithm controls the allocation of resources to processes based on their maximum needs and the available resources. This involves verifying if it is safe to grant resources to processes before doing so. You can create functions to implement these algorithms and simulate the behavior of processes and resources. For example, use functions to allocate and release resources, check safety conditions, identify deadlocks, and manage processes. During the simulation, apply your techniques to different scenarios with various configurations of processes and resources to test and validate your implementation. Analyze the results to verify the effectiveness of deadlock detection and prevention strategies. The input data for testing deadlock detection and prevention may consist of specifications about the processes and the resources they request. Objective: The objective of this activity is to deepen your understanding of deadlock concepts, including detection and prevention methods.
